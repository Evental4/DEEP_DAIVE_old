#include "TXLib.h"

struct Per
{
 int x;
 int y;
 HDC image_left;
 HDC image_raite;
 HDC image;
 int w;
 int h;
 int vx;
 int vy;

 void draw()
 {
 txTransparentBlt(txDC(), x ,y, w,h,image, 0 ,0 , TX_white);
 }

};

int main()
{
txCreateWindow (800, 600);

    HDC fon= txLoadImage("fon.bmp");

    Per dvarf ={400,300,txLoadImage("dvarf_min.bmp"),txLoadImage("dvarf_min_raite.bmp"),dvarf.image_left,100,200,10,10};
    Per bob ={200,216, txLoadImage("draf_left.bmp"),txLoadImage("draf_raite.bmp"),bob.image_left,100,200,10,10};
    Per ckelet={10,10,txLoadImage("ckelet_left.bmp"),txLoadImage("ckelet_raite.bmp"),ckelet,bob.image_raite,193,220,5,5 };
    

    while(!txGetAsyncKeyState (VK_ESCAPE))
    {

        txBegin();
        txClear ();
        //рисование
        txBitBlt(txDC() ,0 ,0, 800,600, fon);
        dvarf.draw();
        bob.draw();
        txTransparentBlt(txDC() , x_ckelet,y_ckelet,w_ckelet,h_ckelet ,ckelet, 0 ,0 , TX_white);
        //движение кл.
        //dvarf передв.
        if(txGetAsyncKeyState ('D'))
        {
            dvarf.x += dvarf.vx;
            dvarf.image= dvarf.image_raite ;
        }

        if(txGetAsyncKeyState ('A'))
        {
            dvarf.x -= dvarf.vx;
            dvarf.image=dvarf.image_left;
        }
        if(txGetAsyncKeyState ('W'))
        {
            dvarf.y -= dvarf.vy;
        }
        if(txGetAsyncKeyState ('S'))
        {
            dvarf.y +=dvarf.vy;
        }
        //draf передвижение
        if(txGetAsyncKeyState ('L'))
        {
            bob.x +=bob.vx;
            bob.image=bob.image_raite ;
        }

        if(txGetAsyncKeyState ('J'))
        {
            bob.x-= bob.vx;
            bob.image=bob.image_left;
        }
        if(txGetAsyncKeyState ('I'))
        {
           bob.y-= bob.vy;
        }
        if(txGetAsyncKeyState ('K'))
        {
            bob.y += bob.vy;
        }
        //движение ии
        x_ckelet=x_ckelet +vx_ckelet;
        if (x_ckelet<0 || x_ckelet+w_ckelet>800)
            vx_ckelet =-vx_ckelet;
        if(vx_ckelet>0) ckelet=ckelet_raite;
        else ckelet=ckelet_left;

        txEnd();
        txSleep(20);


    }

    txDeleteDC (fon);
    txDeleteDC (ckelet_raite );
    txDeleteDC (ckelet_left );
    txDeleteDC (dvarf.image);
    txDeleteDC (bob.image);


txTextCursor (false);
return 0;
}
